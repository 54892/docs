---
title: 'Virtual Fields'
excerpt: 'Virtual Fields allow you to derive new values from your data in real time, eliminating the need for up-front data structuring, enhancing flexibility and efficiency.'
tags:
  ['axiom documentation', 'documentation', 'axiom', 'virtual fields', 'virtualization', 'array functions', 'filters', 'literals', 'numeric operators']
---

# Virtual Fields

**Virtual Fields allow you to derive new values from your data in real time**

One of the most powerful features of Axiom are Virtual Fields. With Virtual Fields, there is no need to do any up-front planning of how to structure or transform your data. Instead, send your data as-is and then use Virtual Fields to manipulate your data in real-time during queries.

The feature is also known has "derived columns/fields", however Axiom's Virtual Fields have some unique properties that make them much more powerful.

In this guide, you'll be introduced to Virtual Fields, their features, how to manage them, and how to get the best out of them.

## Creating a Virtual Field

Once a dataset is selected in either the [Analytics](/docs/usage/analyze) or [Stream](/docs/usage/stream) views, clicking the virtual fields icon in the toolbar will open the virtual field slide-out that displays all the virtual fields for a dataset:

![Virtual fields tool button](/doc-assets/shots/analyze-toolbar-vfields.png 'Virtual fields tool button')

---

![Virtual fields slide-out](/doc-assets/shots/v1.png 'Virtual fields slide-out')

---

**Click "Add Virtual Field" to open the virtual field editor dialog.**

![Virtual field editor](/doc-assets/shots/v2.png 'Virtual field editor')

---

The editor dialog has the following components:

- **Name** & **Description** - help your team understand what the virtual field is doing
- **Expression** - this the expression that is run on every event to derive the virtual field. The expression would produce some output (from a `boolean` check like the example, to `strings`, `numbers`, `objects` or more)
- **Preview** - use the preview window to test your virtual field expression against live data

The power of virtual fields is in letting you manipulate data 'on read' instead of 'on write', allowing you and your team members to adjust and update virtual fields over time as well as easily add new ones without worrying that the data has already been indexed.

## Usage

### Visualizations

Virtual Fields will be available as parameters to visualizations but, as the type of a virtual field can be any of the supported types, it is important to make sure that you are using a virtual field that produces the correct type of argument.

### Filters

Virtual Fields will be available in the filter menu and all filter options will be presented. It is important to ensure that you are using a supported filter operation for the type of result your virtual field produces.

## Group By

Virtual Fields can be used for segmentation in the same way as any standard field.

## Reference

Virtual Fields use a rich expression language that is easy to grasp but powerful in use. This section documents the language and the functions available.

To make things easier, Virtual Fields are just APL expressions (e.g. `extend alias1 = expression1, alias2 = expression2, alias3 = ...` ) , and therefore Virtual Fields share all the same functions and syntax as APL expressions. To learn more about APL, click [here](/docs/apl/introduction).

Below is a list of APL scalar functions:

- [String functions](/docs/apl/scalar-functions/string-functions)
- [Math functions](/docs/apl/scalar-functions/mathematical-functions)
- [Array functions](/docs/apl/scalar-functions/array-functions)
- [Conversion functions](/docs/apl/scalar-functions/conversion-functions)
- [Hash functions](/docs/apl/scalar-functions/hash-functions)
- [DateTime/Timespan functions](/docs/apl/scalar-functions/datetime-functions)
- [Rounding functions](/docs/apl/scalar-functions/rounding-functions)
- [Conditional functions](/docs/apl/scalar-functions/conditional-function)
- [IP functions](/docs/apl/scalar-functions/ip-functions)

{/*
### Literals

| **Functions** | **Description**                         |
| ------------- | --------------------------------------- |
| `strings`     | single and double quotes are supported. |
| `numbers`     | `101`, `101.1`                          |
| `booleans`    | `true` and `false`                      |
| `arrays`      | `["one", "two", "three"]`               |
| `maps`        | `{ region: "us-east-1" }`               |
| `nil` -       | `nil`                                   |

### Arithmetic Operators

| **Operator** | **Description** |
| ------------ | --------------- |
| `+`          | addition        |
| `-`          | subtraction     |
| `*`          | multiplication  |
| `/`          | division        |
| `%`          | modulus         |
| `**`         | pow             |

### Comparison Operators

| **Operator** | **Description**          |
| ------------ | ------------------------ |
| `==`         | equal                    |
| `!=`         | not equal                |
| `<`          | less than                |
| `>`          | greater than             |
| `<=`         | less than or equal to    |
| `>=`         | greater than or equal to |

### Logical Operators

| **Operator**                           | 
| -------------------------------------- |
| `and` or `&&`                          |
| `or` or `                              |    
| `not` or `!`                           |
| `success ? 'yes' : 'no'` - **ternary** |

### String Operators

| **Operator** | **Description** |
| ------------ | --------------- |
| `+`          | concatenation   |
| `matches`    | regex match     |
| `contains`   | string contains |
| `startsWith` | has prefix      |
| `endsWith`   | has suffix      |

---

<CallOut kind="info">
  To test the negative case of not matching, wrap the operator in a `not()` operator:
  <br />
  `not ("us-east-1" contains "us")`
  <br />
  You must use parentesis because the unary operator `not` has precedence over the binary operator `contains`.
</CallOut>

### Numeric Operators

In addition to the [arithmetic operators](#arithmetic-operators):

- `..` - numeric range

<CallOut kind="example">`age in 18..45`</CallOut>

<CallOut kind="tip">The range is inclusive: `1..3 == [1, 2, 3]`</CallOut>

---

### Membership Operators

| **Operator** | **Description**      |
| ------------ | -------------------- |
| `in`         | **contains**         |
| `not in`     | **does not contain** |

<CallOut kind="example">
  {`Arrays: metadata.region in ["us-east-1", "us-east-2"]`}
  <br />
  {`Maps: 'region' in { region: 'us-east-1 } // true`}
</CallOut>

---

### Builtins

| **Operator** | **Description**                                                  |
| ------------ | ---------------------------------------------------------------- |
| `len`        | length of an array, map, or string                               |
| `all`        | will return true if all element satisfies the predicate          |
| `none`       | will return true if all element does NOT satisfies the predicate |
| `any`        | will return true if any element satisfies the predicate          |
| `one`        | will return true if exactly ONE element satisfies the predicate  |
| `filter`     | filter array by the predicate                                    |
| `map`        | map all items with the closure                                   |
| `count`      | returns number of elements what satisfies the predicate          |

<CallOut kind="example" title="Ensure all comments are less than 280 chars">
  {'all(comments, {.Size < 280})'}
</CallOut>

<CallOut kind="example" title="Ensure there is exactly one private repo">
  {'one(repos, {.private})'}
</CallOut>

---

### Closures

- `{...}` - closure

Closures allowed only with builtin functions. To access the current item, used the `#` symbol.

<CallOut kind="example">{'`map(0..9, {# / 2})`'}</CallOut>

If the item of array is struct, it's possible to access fields of struct with omitted `#` symbol (`#.Value` becomes `.Value`).

<CallOut kind="example">{'filter(comments, {len(.body) > 280})'}</CallOut>

### Slices

- `myArray[:]` - slice

Slices can work with arrays or strings

<CallOut kind="example">
  The variable `myArray` is `[1, 2, 3, 4, 5]`
  <br /> `myArray[1:5] == [2, 3, 4] myArray[3:] == [4, 5] myArray[:4] == [1, 2, 3] myArray[:] == myArray`
</CallOut>
*/}

